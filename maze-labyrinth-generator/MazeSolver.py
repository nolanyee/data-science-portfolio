'''
This program generates random mazes and labyrinths of specified size, and solves them.

The default maze is generated using the union of disjoint sets.
The branch parameter determines the maximum number of walls that can be deleted during maze generation. This parameter
must be > 2, but does not need to be an integer. The loop parameter creates multiple paths to the target cell.

If Grid is selected, the maze is divided into blocks of specified size, and a labyrinth is generated in each block using
depth first search (keep block size < 7). Then the maze is generated by union of the blocks. The user may build
or destroy walls in the maze or move the target.

If labyrinth is selected, an alternative labyrinth generating algorithm is used, based on the union of disjoint cyclical
ordered sets. The dead end parameter controls how likely dead ends will be generated, through subdivision of the
labyrinth path and the performing union on the resulting disjoint paths. The labyrinth start and end points are set
by using Ctrl+Left Click and Ctrl+Right Click. Not all combinations of starting and ending points can yield a labyrinth.
In these cases the path will be extended beyond the end or start point. Usually moving either point by 1 space will
create a feasible labyrinth.

Depending on the parameters and user actions, there may be multiple solutions to the maze.
The shortest solution path is calculated using Dijkstra's algorithm.
'''

from tkinter import *
from tkinter.ttk import *
from random import *
from itertools import *

# Widget Creation
window = Tk(className = ' Maze Solver')
subframe = Frame(window)
subframe.pack(side=BOTTOM, fill=BOTH)
generatebutton = Button(subframe,text='Generate',command=lambda :generate()) # Generates the maze
widthlabel = Label(subframe,text='Width')
heightlabel = Label(subframe,text='Height')
branchlabel = Label(subframe,text='Branches')
looplabel = Label(subframe,text='Loops')
widthentry = Entry(subframe,width=5) # Specify maze width
heightentry = Entry(subframe,width=5) # Specify maze height
branchentry = Entry(subframe,width=5) # Specify degree of branching, must be > 2
loopentry = Entry(subframe,width=5) # Specify multiple paths
solutionbutton = Button(subframe,text='Solution',command=lambda :solve()) # Show or hide maze solution
labvar = IntVar()
labbutton =Checkbutton(subframe,text='Labyrinth',variable=labvar,command = lambda:lab()) # Select for labyrinth
deadendslabel = Label(subframe,text='  Dead Ends')
deadendsentry = Entry(subframe,width=5)
gridvar = IntVar()
gridbutton =Checkbutton(subframe,text='Grid',variable=gridvar,command = lambda:grid()) # Select for grid-based maze
gridentry = Entry(subframe,width=5)

# Widget Packing
generatebutton.pack(side=LEFT)
labbutton.pack(side=LEFT)
deadendslabel.pack(side=LEFT)
deadendsentry.pack(side=LEFT)
gridbutton.pack(side=LEFT)
gridentry.pack(side=LEFT)
widthlabel.pack(side=LEFT)
widthentry.pack(side=LEFT)
heightlabel.pack(side=LEFT)
heightentry.pack(side=LEFT)
branchlabel.pack(side=LEFT)
branchentry.pack(side=LEFT)
looplabel.pack(side=LEFT)
loopentry.pack(side=LEFT)
solutionbutton.pack(side=LEFT)
sheet = Canvas(window, width = 850, height = 600)
sheet.pack(fill=BOTH, expand = True)

# Entry Initialization
widthentry.insert(0,20)
heightentry.insert(0,20)
branchentry.insert(0,2.01)
loopentry.insert(0,0)
gridentry.insert(0,2)
deadendsentry.insert(0,0)
gridentry.config(state=DISABLED)
deadendsentry.config(state=DISABLED)

# Global Variables
size = (int(widthentry.get()),int(heightentry.get())) # Size of Maze
previoussize = size[:] # To detect changes in size
branching = float(branchentry.get()) # How many branches to allow
alternatepaths = int(loopentry.get()) # Alternate path parameter
offset = (50,50) # Left and top margin
width = 20 # Width of cells
linelist = [] # List of all line objects
breaklist = [] # Stores two cell locations to be merged by the breaking of a wall
buildlist = [] # Stores two cell locations to be split by the building of a wall
solution = [] # Stores all line objects in the maze solution
showsolution = False # Indicates whether the solution is shown or not
entrance = None # Entrance to the maze
turtle = None # Player location marker
target = None # End of maze
goal = None # Marker for end of maze
position = None # Position of player
turtlesize = 5 # Size of markers
entrancedefaultkey = 'cell0-0' # Default entrance location
targetdefaultkey = 'cell' + str(size[0] - 1) + '-' + str(size[1] - 1) # Default end location

class cell(): # Each cell of the maze is a cell object
    def __init__(self,x,y):
        self.xindex = x # Indices expressed in terms of cells
        self.yindex = y
        self.x = x*width+offset[0] # Absolute location of top left corner
        self.y = y*width+offset[1]
        self.xcenter = x*width+offset[0]+width//2 # Absolute location of center of cell
        self.ycenter = y*width+offset[1]+width//2
        # Creation of the walls of the cell
        if 'h'+str(x)+'-'+str(y) not in globals(): # To prevent duplicate wall creation
            globals().update({'h' + str(x) + '-' + str(y):
                                  sheet.create_line(self.x, self.y, self.x + width, self.y)})
        if 'h' + str(x) + '-' + str(y + 1) not in globals():
            globals().update({'h' + str(x) + '-' + str(y + 1):
                                  sheet.create_line(self.x, self.y + width, self.x + width, self.y + width)})
        if 'v' + str(x) + '-' + str(y) not in globals():
            globals().update({'v' + str(x) + '-' + str(y):
                                  sheet.create_line(self.x, self.y, self.x, self.y + width)})
        if 'v' + str(x + 1) + '-' + str(y) not in globals():
            globals().update({'v' + str(x + 1) + '-' + str(y):
                                  sheet.create_line(self.x + width, self.y, self.x + width, self.y + width)})
        # Assigning created lines to cell attributes top, bottom, left, and right
        self.top = globals()['h'+str(x)+'-'+str(y)]
        self.bottom = globals()['h' + str(x) + '-' + str(y+1)]
        self.left = globals()['v' + str(x) + '-' + str(y)]
        self.right = globals()['v' + str(x+1) + '-' + str(y)]
        self.connections = [] # Cells accessible from current cell
        self.entrance = False # True if cell is entrance
        self.exit = False # True if cell has an exit to the maze
        self.target = False # True if cell is the target
        self.adjacentlist = [] # All adjacent cells (connected or not)
        self.moves = len(self.adjacentlist)
        self.tracker = size[0]*size[1]+1 # For use in Dijkstra's algorithm
        self.pathlist = [self] # For use in Dijkstra's algorithm

    def updateadjacent(self): # Updating adjacent list (after all cells are created)
        if self.yindex != 0:
            self.adjacentlist.append(globals()['cell'+str(self.xindex)+'-'+str(self.yindex-1)])
        if self.yindex != size[1]-1:
            self.adjacentlist.append(globals()['cell'+str(self.xindex)+'-'+str(self.yindex+1)])
        if self.xindex != 0:
            self.adjacentlist.append(globals()['cell'+str(self.xindex-1)+'-'+str(self.yindex)])
        if self.xindex != size[0]-1:
            self.adjacentlist.append(globals()['cell'+str(self.xindex+1)+'-'+str(self.yindex)])
    # Methods to delete any of the four walls of the cell
    def breaktop(self):
        sheet.delete(self.top)
        adjacent  = globals()['cell'+str(self.xindex)+'-'+str(self.yindex-1)]
        self.top = None
        if adjacent:
            adjacent.bottom = None
            connect(self,adjacent)
        else:
            self.exit = True
    def breakbottom(self):
        sheet.delete(self.bottom)
        adjacent  = globals()['cell'+str(self.xindex)+'-'+str(self.yindex+1)]
        self.bottom = None
        if adjacent:
            adjacent.top = None
            connect(self,adjacent)
        else:
            self.exit = True
    def breakleft(self):
        sheet.delete(self.left)
        adjacent  = globals()['cell'+str(self.xindex-1)+'-'+str(self.yindex)]
        self.left = None
        if adjacent:
            adjacent.right = None
            connect(self,adjacent)
        else:
            self.exit = True
    def breakright(self):
        sheet.delete(self.right)
        adjacent  = globals()['cell'+str(self.xindex+1)+'-'+str(self.yindex)]
        self.right = None
        if adjacent:
            adjacent.left = None
            connect(self,adjacent)
        else:
            self.exit = True
    # Method to merge two cells together
    def mergeneighbor(self,neighbor):
        if self.xindex == neighbor.xindex+1:
            self.breakleft()
        elif self.xindex == neighbor.xindex-1:
            self.breakright()
        elif self.yindex == neighbor.yindex+1:
            self.breaktop()
        elif self.yindex == neighbor.yindex-1:
            self.breakbottom()

# Resets certain global variables and deletes all cell objects, lines, and markers
def reset():
    global size
    global branching
    global alternatepaths
    global linelist
    global breaklist
    global buildlist
    global goal
    global turtle
    global solution
    linelist = []
    breaklist = []
    buildlist = []
    for i in range(0, size[0]):
        for j in range(0, size[1]):
                sheet.delete(globals()['h' + str(i) + '-' + str(j)])
                del globals()['h' + str(i) + '-' + str(j)]
                sheet.delete(globals()['v' + str(i) + '-' + str(j)])
                del globals()['v' + str(i) + '-' + str(j)]
    for i in range(0, size[0]):
                sheet.delete(globals()['h' + str(i) + '-' + str(size[1])])
                del globals()['h' + str(i) + '-' + str(size[1])]
    for i in range(0, size[1]):
                sheet.delete(globals()['v' + str(size[0]) + '-' + str(i)])
                del globals()['v' + str(size[0]) + '-' + str(i)]
    for i in range(0,size[0]):
        for j in range(0,size[1]):
            del globals()['cell'+str(i)+'-'+str(j)]
    for x in solution:
        sheet.delete(x)
    solution=[]
    size = (int(widthentry.get()), int(heightentry.get()))
    branching = float(branchentry.get())
    alternatepaths = int(loopentry.get())
    sheet.delete(turtle)
    sheet.delete(goal)

# Initializes the program by creating all the cell objects and setting the default entrance and target locations
def initialize():
    global previoussize
    global size
    size = (int(widthentry.get()), int(heightentry.get()))
    if previoussize != size:
        updatedefault()
        previoussize = list(size)[:]
    for i in range(0,size[0]):
        for j in range(0,size[1]):
            globals().update({'cell'+str(i)+'-'+str(j):cell(i,j)})
    for i in range(0,size[0]):
        for j in range(0,size[1]):
            globals()['cell'+str(i)+'-'+str(j)].updateadjacent()
    defaultentrancetarget()

# Sets default entrance and target cells
def defaultentrancetarget():
    global entrance
    global target
    entrance = globals()[entrancedefaultkey]
    target = globals()[targetdefaultkey]

# Returns the cell given coordinates
def incell(x,y):
    coordkey = 'cell'+str((x-offset[0])//width)+'-'+str((y-offset[1])//width)
    if coordkey in globals():
        return globals()[coordkey]

# Connect two cells
def connect(a,b):
    a.connections.append(b)
    b.connections.append(a)

# Disconnect two cells
def disconnect(a,b):
    a.connections.remove(b)
    b.connections.remove(a)

# For border cells, returns an wall (line) that is on the outside of the maze
def edgecases(a):
    if a.xindex == 0:
        return a.left
    elif a.xindex == size[0] - 1:
        return a.right
    elif a.yindex == 0:
        return a.top
    elif a.yindex == size[1] - 1:
        return a.bottom

# Deletes the references to border walls that have been deleted
def clearedgecase(a):
    if a.xindex == 0:
        a.left = None
    elif a.xindex == size[0] - 1:
        a.right = None
    elif a.yindex == 0:
        a.top = None
    elif a.yindex == size[1] - 1:
        a.bottom = None

# Creates new line objects for border walls that have been created
def rebuildedgecase(a):
    if a.xindex == 0:
        globals().update({'v' + str(a.xindex) + '-' + str(a.yindex):
                              sheet.create_line(a.x, a.y, a.x, a.y + width)})
        a.left = globals()['v' + str(a.xindex) + '-' + str(a.yindex)]
    elif a.xindex == size[0] - 1:
        globals().update({'v' + str(a.xindex + 1) + '-' + str(a.yindex):
                              sheet.create_line(a.x + width, a.y, a.x + width, a.y + width)})
        a.right = globals()['v' + str(a.xindex + 1) + '-' + str(a.yindex)]
    elif a.yindex == 0:
        globals().update({'h' + str(a.xindex) + '-' + str(a.yindex):
                              sheet.create_line(a.x, a.y, a.x + width, a.y)})
        a.top = globals()['h' + str(a.xindex) + '-' + str(a.yindex)]
    elif a.yindex == size[1] - 1:
        globals().update({'h' + str(a.xindex) + '-' + str(a.yindex + 1):
                              sheet.create_line(a.x, a.y + width, a.x + width, a.y + width)})
        a.bottom = globals()['h' + str(a.xindex) + '-' + str(a.yindex + 1)]

# Returns the shared wall between two cells
def commonedge(a,b):
    if a is None and b is not None:
        return edgecases(b)
    elif b is None and a is not None:
        return edgecases(a)
    elif a.xindex == b.xindex and b.yindex==a.yindex-1:
        return a.top
    elif a.xindex == b.xindex and b.yindex == a.yindex + 1:
        return a.bottom
    elif a.xindex == b.xindex -1 and a.yindex == b.yindex:
        return a.right
    elif a.xindex == b.xindex + 1 and a.yindex == b.yindex:
        return a.left
    else:
        return False

# Returns a cell with the specified wall
def edgecell(edge):
    for key, value in globals().items():
        if edge == value and 'h' in key and '-' in key:
            result = globals()[key.replace('h','cell')]
            return [result,'top',globals()['cell'+str(result.xindex)+'-'+str(result.yindex-1)]]
        elif edge == value and 'v' in key:
            result = globals()[key.replace('v', 'cell')]
            return [result,'left',globals()['cell'+str(result.xindex-1)+'-'+str(result.yindex)]]

# Procedure to tear down the wall between two cells, if they are adjacent
def breakprocedure(a,b):
    sheet.delete(commonedge(a, b))
    if a is None and b is not None:
        clearedgecase(b)
        b.exit = True
    elif b is None and a is not None:
        clearedgecase(a)
        a.exit = True
    elif a.xindex == b.xindex and b.yindex == a.yindex - 1:
        a.top = None
        b.bottom = None
        connect(a, b)
    elif a.xindex == b.xindex and b.yindex == a.yindex + 1:
        a.bottom = None
        b.top = None
        connect(a, b)
    elif a.xindex == b.xindex + 1 and a.yindex == b.yindex:
        a.left = None
        b.right = None
        connect(a, b)
    elif a.xindex == b.xindex - 1 and a.yindex == b.yindex:
        a.right = None
        b.left = None
        connect(a, b)

# Break wall upon Alt-Click in two neighboring cells
def breakwall(event):
    global breaklist
    if breaklist == []:
        breaklist.append(incell(event.x, event.y))
    elif len(breaklist)==1:
        breaklist.append(incell(event.x, event.y))
        if commonedge(breaklist[0],breaklist[1])is None:
            breaklist = []
        else:
            a = breaklist[0]
            b = breaklist[1]
            breakprocedure(a,b)
    else:
        breaklist = [incell(event.x, event.y)]

# Checks for adjacency of input cells then breaks the wall given two cells
def breakwallauto(a,b):
        if commonedge(a,b)is None:
            return None
        else:
            breakprocedure(a,b)

# Procedure to build a wall between two adjacent cells
def buildprocedure(a,b):
    global buildlist
    if a is None and b is not None:
        rebuildedgecase(b)
        b.exit = False
    elif b is None and a is not None:
        rebuildedgecase(a)
        a.exit = False
    elif a.xindex == b.xindex and b.yindex == a.yindex - 1:
        globals().update({'h' + str(a.xindex) + '-' + str(a.yindex):
                              sheet.create_line(a.x, a.y, a.x + width, a.y)})
        a.top = globals()['h' + str(a.xindex) + '-' + str(a.yindex)]
        b.bottom = globals()['h' + str(b.xindex) + '-' + str(b.yindex + 1)]
        disconnect(a, b)
    elif a.xindex == b.xindex and b.yindex == a.yindex + 1:
        globals().update({'h' + str(a.xindex) + '-' + str(a.yindex + 1):
                              sheet.create_line(a.x, a.y + width, a.x + width, a.y + width)})
        a.bottom = globals()['h' + str(a.xindex) + '-' + str(a.yindex + 1)]
        b.top = globals()['h' + str(b.xindex) + '-' + str(b.yindex)]
        disconnect(a, b)
    elif a.xindex == b.xindex + 1 and a.yindex == b.yindex:
        globals().update({'v' + str(a.xindex) + '-' + str(a.yindex):
                              sheet.create_line(a.x, a.y, a.x, a.y + width)})
        a.left = globals()['v' + str(a.xindex) + '-' + str(a.yindex)]
        b.right = globals()['v' + str(b.xindex + 1) + '-' + str(b.yindex)]
        disconnect(a, b)
    elif a.xindex == b.xindex - 1 and a.yindex == b.yindex:
        globals().update({'v' + str(a.xindex + 1) + '-' + str(a.yindex):
                              sheet.create_line(a.x + width, a.y, a.x + width, a.y + width)})
        a.right = globals()['v' + str(a.xindex + 1) + '-' + str(a.yindex)]
        b.left = globals()['v' + str(b.xindex) + '-' + str(b.yindex)]
        disconnect(a, b)

# Build a wall upon Shift-Click in two adjacent cells
def buildwall(event):
    global buildlist
    if buildlist == []:
        buildlist.append(incell(event.x, event.y))
    elif len(buildlist)==1:
        buildlist.append(incell(event.x, event.y))
        if commonedge(buildlist[0],buildlist[1])is False:
            buildlist = []
        elif commonedge(buildlist[0],buildlist[1]) is None:
            a = buildlist[0]
            b = buildlist[1]
            buildprocedure(a,b)
    else:
        buildlist = [incell(event.x, event.y)]

# Checks for adjacency of cells and builds a wall between them
def buildwallauto(a,b):
    if commonedge(a,b) is None:
        buildprocedure(a, b)
    else:
        return None

# A set of cells with special union operations
class cellset():
    def __init__(self,*args):
        self.items = set(args)
        self.bordercells = [] # Cells on the border of the set
        self.edgelist = [] # Walls (edges) on the border of the set
        self.updateborder()

    def updateborder(self): # Updates the border cell and border wall lists
        self.edgelist = []
        self.bordercells = []
        for x in self.items:
            for y in x.adjacentlist:
                if y not in self.items:
                    self.bordercells.append(x)
                    self.edgelist.append(commonedge(x, y))

    def union(self, arg): # Union procedure, deletes one wall shared by two adjacent sets
        borderedges = list(set(self.edgelist).intersection(arg.edgelist))
        x = choice(borderedges)
        if edgecell(x):
            if branching % 1 > random(): # Frequency of allowed branches depends on specified branching number
                randombranch = 1
            else:
                randombranch = 0
            branch = int(branching) + randombranch
            if (len(edgecell(x)[0].connections) < branch and edgecell(x)[2] is None) or \
                    (len(edgecell(x)[0].connections) < branch and len(edgecell(x)[2].connections) < branch):
                if edgecell(x)[1] == 'top':
                    edgecell(x)[0].breaktop()
                elif edgecell(x)[1] == 'left':
                    edgecell(x)[0].breakleft()
                return cellset(*self.items.union(arg.items))

    def union2(self,arg): # Deletes 2 walls shared by two adjacent sets to allow for multiple paths
        borderedges = list(set(self.edgelist).intersection(arg.edgelist))
        temp = borderedges
        x = choice(temp)
        temp.remove(x)
        if temp != []:
            y = choice(temp)
        else:
            y=x
        if edgecell(x) and edgecell(y):
            if branching % 1 > random():
                randombranch = 1
            else:
                randombranch = 0
            branch = int(branching) + randombranch
            if (len(edgecell(x)[0].connections) < branch and edgecell(x)[2] is None) or \
                    (len(edgecell(x)[0].connections) < branch and len(edgecell(x)[2].connections) < branch) and \
                    (len(edgecell(y)[0].connections) < branch and edgecell(y)[2] is None) or \
                    (len(edgecell(y)[0].connections) < branch and len(edgecell(y)[2].connections) < branch):
                if edgecell(x)[1] == 'top':
                    edgecell(x)[0].breaktop()
                elif edgecell(x)[1] == 'left':
                    edgecell(x)[0].breakleft()
                if edgecell(y)[1] == 'top':
                    edgecell(y)[0].breaktop()
                elif edgecell(y)[1] == 'left':
                    edgecell(y)[0].breakleft()
                return cellset(*self.items.union(arg.items))

# Procedure to union sets until there is only one
def mergecellsets(sets):
    def updatesetlist(a,b,multiple = False):
        nonlocal sets
        if not multiple:
            c = a.union(b)
        else:
            c = a.union2(b)
        if c:
            sets.remove(a)
            sets.remove(b)
            sets.append(c)
            c.updateborder()
    while len(sets) > 1:
        temp = sets[:] # Prevents picking the same two nonadjacent cells
        x = choice(temp)
        temp.remove(x)
        y = choice(temp)
        while list(set(x.edgelist).intersection(y.edgelist)) == []:
            temp.remove(y)
            y = choice(temp)
        if alternatepaths+2 > len(sets): # Alternate paths are created towards the end, when sets are large
            updatesetlist(x, y,multiple=True)
        else:
            updatesetlist(x, y,multiple=False)

# Procedure to generate maze
def generatemaze():
    global entrance
    global target
    reset()
    initialize()
    setlist = []
    for i in range(0, size[0]): # Create cell sets
        for j in range(0, size[1]):
            globals().update({'set'+str(i)+'-'+str(j):cellset(globals()['cell'+str(i)+'-'+str(j)])})
            setlist.append(globals()['set'+str(i)+'-'+str(j)])
    mergecellsets(setlist)
    entrance.entrance = True
    target.target = True
    createturtle()
    creategoal()

# Procedure to merge a list of cells into one path
def loop(*args,cycle=False):
    for i in range(0, len(args) - 1):
        args[i].mergeneighbor(args[i + 1])
    if cycle == True: # If the path is a cycle, the beginning and end are merged
        if commonedge(args[0], args[-1]):
            args[len(args) - 1].mergeneighbor(args[0])

# Procedure for generating small labyrinths within the maze using depth first search
def tour(X,Y,L,H,threshold = 0):
    global entrance
    global target
    a = randint(0,1) # Random integer determined which corner to start. The end will be the diagonal corner.
    if int(L)%2==0 and int(H)%2==0:
        if a == 0:
            entrance = globals()['cell'+str(X)+'-'+str(int(Y+1))]
        else:
            entrance = globals()['cell' + str(int(X)+int(L)-1) + '-' + str(int(Y + 1))]
    else:
        if a ==0:
            entrance = globals()['cell'+str(X)+'-'+str(Y)]
        else:
            entrance = globals()['cell' + str(int(X)+int(L)-1) + '-' + str(Y)]
    if a==0:
        target = globals()['cell' + str(int(X)+int(L)-1) + '-' + str(int(Y)+int(H)-1)]
    else:
        target = globals()['cell' + str(int(X)) + '-' + str(int(Y)+int(H)-1)]
    entrance.entrance = True
    target.target = True
    notexplored = [] # Populate the list of not explored cells
    for i in range(int(X), int(X)+int(L)):
        for j in range(int(Y), int(Y)+int(H)):
            notexplored.append(globals()['cell' + str(i) + '-' + str(j)])
    found = False
    path = []
    def toursub(vertex): # Depth first search
        nonlocal found
        notexplored.remove(vertex)
        if len(notexplored) > int(threshold) or vertex != target:
            for v in vertex.adjacentlist: # priority is given to cells with fewer unexplored adjacent cells
                v.moves = len(set(v.adjacentlist).intersection(notexplored))
            sortedadjacent = sorted(vertex.adjacentlist,key = lambda a: a.moves)
            for v in sortedadjacent: # Recursive call
                if v in notexplored:
                    toursub(v)
            if not found: # Backtrack
                notexplored.append(vertex)
            else:
                path.append(vertex)
        else:
            found = True
            path.append(vertex)
    for vertex in notexplored:
        shuffle(vertex.adjacentlist) # For randomness
    toursub(entrance)
    if path:
        if L ==2 and H ==2: # Randomly rotate if blocks are 2x2 for more variety, since there is only one 2x2 labyrinth
            a = randint(0, 3)
            b = 0
            while b < a:
                temp = path.pop(0)
                path.append(temp)
                b += 1
        labyrinth = loop(*path) # Connect the cells in the labyrinth
        blockset = cellset()
        for x in path: # Create and return a cell set for the block
            blockset.items=blockset.items.union([globals()['cell' + str(x.xindex) + '-' + str(x.yindex)]])
        return blockset

def subdivide(blocksize = 6): # Subdivides maze into blocks, generates labyrinth in each, then unions the blocks
    global entrance
    global target
    reset()
    initialize()
    columns = size[0] // blocksize # Calculate number of blocks
    colmargin = size[0] % blocksize
    rows = size[1] // blocksize
    rowmargin = size[1] % blocksize
    blockid = 0
    setlist = []
    for i in range(0,columns+1): # Create labyrinth blocks
        for j in range(0, rows + 1):
            if i == columns:
                L = colmargin
            else:
                L=blocksize
            if j == rows:
                H = rowmargin
            else:
                H=blocksize
            if L != 0 and H != 0:
                globals().update({'block' + str(blockid): tour(i * blocksize, j * blocksize, L, H)})
                setlist.append(globals()['block' + str(blockid)])
    for x in setlist: # Update borders of block sets
        x.updateborder()
    mergecellsets(setlist) # Union the disjoint block sets
    defaultentrancetarget()
    entrance.entrance = True
    target.target = True
    createturtle()
    creategoal()

class cycledlist(): # Create class for cycled lists
    def __init__(self,x):
        self.list = x
    def iscycle(self): # Determines if the list is cyclical if the first and last cell are adjacent
        if len(self.list) !=2 and len(self.list)<4:
            return False
        elif commonedge(self.list[0], self.list[-1]):
            return True
        else:
            return False
    def rotate(self): # Rotate the items in the list
        temp = self.list.pop(0)
        self.list.append(temp)
    def reverse(self): # Reverse the items in the list
        self.list.reverse()
    def isinorder(self,testlist): # Checks if cells in the list are all adjacent to neighboring cells in the list
        for a in testlist[:len(testlist)-1]:
            if testlist[testlist.index(a)+1] not in a.adjacentlist:
                return False
        return True
    def rearrange(self): # Rearrange items until they are in order
        for a in permutations(self.list):
            if self.isinorder(list(a)):
                self.list = list(a)
                break
    def isconnected(self,a,b): # Checks if two cells are next to each other in the cycle
        if (a == self.list[0] and b == self.list[-1]) or (a == self.list[-1] and b == self.list[0]): # For ends
            if commonedge(a,b):
                return True
            else:
                return False
        else:
            if abs(self.list.index(a)-self.list.index(b))==1:
                return True
            else:
                return False
    def union(self,other): # Procedure for union of cycles
        if not self.iscycle() and not other.iscycle(): # Two non-cycles cannot be united, at least one must be cyclical
            return None
        bordercells = []
        for x in self.list: # Generates pairs of neighboring cells from two lists
            for y in other.list:
                if x in y.adjacentlist:
                    bordercells.append([x,y])
        quadruplet = []
        for a in bordercells: # Generates possible quadruplets (aligned pairs are adjacent in each list)
            for b in [x for x in bordercells if bordercells.index(x)>bordercells.index(a)]:
                if self.isconnected(a[0],b[0]) and other.isconnected(a[1],b[1]):
                    quadruplet.append([a,b])
        if quadruplet == []:
            return None
        else: # Merges the lists into one ordered list by inserting a list into a break in the other list
            merged = choice(quadruplet)
            while len(other.list)>2 and (other.list.index(merged[1][1]) - other.list.index(merged[0][1])) ** 2 != 1:
                other.rotate()
            while other.list.index(merged[1][1]) - other.list.index(merged[0][1]) != 1:
                other.reverse() # To have the quadruplet cells in order in the other list
            while len(self.list)>2 and (self.list.index(merged[1][0]) - self.list.index(merged[0][0])) ** 2 == 1:
                self.rotate()
            while self.list.index(merged[0][0]) != 0:
                self.reverse() # To have the quadruplet cells at the ends of the self list
            unitedlist = other.list[:other.list.index(merged[0][1])+1] + self.list + other.list[
                                                                            other.list.index(merged[1][1]):]
            newlist=cycledlist(unitedlist)
            if not self.isinorder(unitedlist): # Rotate until break is at the ends of the new list (if not 2 cycles)
                while not self.isinorder(newlist.list):
                    newlist.rotate()
            return newlist

def labyrinth(branch = 20): # Procedure to create labyrinth
    global entrance
    global target
    reset()
    initialize()
    entrancecoordinates = [entrance.xindex, entrance.yindex]
    targetcoordinates = [target.xindex, target.yindex]
    if entrancecoordinates[0]==1: # Any start or end cell that is 1 away from the edge is moved to the edge for speed
        entrancecoordinates[0]=0
    elif entrancecoordinates[0]==size[0]-2:
        entrancecoordinates[0]=size[0]-1
    if entrancecoordinates[1]==1:
        entrancecoordinates[1]=0
    elif entrancecoordinates[1]==size[1]-2:
        entrancecoordinates[1]=size[1]-1
    if targetcoordinates[0]==1:
        targetcoordinates[0]=0
    elif targetcoordinates[0]==size[0]-2:
        targetcoordinates[0]=size[0]-1
    if targetcoordinates[1]==1:
        targetcoordinates[1]=0
    elif targetcoordinates[1]==size[1]-2:
        targetcoordinates[1]=size[1]-1
    entrance = globals()['cell'+str(entrancecoordinates[0])+'-'+str(entrancecoordinates[1])]
    target = globals()['cell' + str(targetcoordinates[0]) + '-' + str(targetcoordinates[1])]
    pathlist = []
    cyclesetlist = []
    notunionlist = []
    if targetcoordinates[0] >= entrancecoordinates[0]: # A path is created from the entrance to target
        for i in range(entrancecoordinates[0], targetcoordinates[0] + 1):
            pathlist.append(globals()['cell' + str(i) + '-' + str(entrancecoordinates[1])])
    else:
        for i in range(entrancecoordinates[0], targetcoordinates[0] - 1,-1):
            pathlist.append(globals()['cell' + str(i) + '-' + str(entrancecoordinates[1])])
    if targetcoordinates[1] >= entrancecoordinates[1]:
        for i in range(entrancecoordinates[1] + 1, targetcoordinates[1] + 1):
            pathlist.append(globals()['cell' + str(targetcoordinates[0]) + '-' + str(i)])
    else:
        for i in range(entrancecoordinates[1] - 1, targetcoordinates[1] - 1,-1):
            pathlist.append(globals()['cell' + str(targetcoordinates[0]) + '-' + str(i)])
    def labyrinthgrid(arange=(0,2),brange=(0,2)): # Cycles of 4 cells are created to fill the remaining space
        nonlocal pathlist
        nonlocal cyclesetlist
        nonlocal notunionlist
        cyclesetlist = []
        notunionlist = []
        for i in range(0, size[0] // 2 + size[0] % 2 + 1):
            for j in range(0, size[1] // 2 + size[1] % 2 + 1):
                celllist = []
                for a in range(*arange): # Cycles at the borders of the maze may be truncated
                    for b in range(*brange): # Cells in the created path are excluded from the cycles
                        if -1 <2 * i + a < size[0] and -1 <2 * j + b < size[1]:
                            if globals()['cell' + str(2 * i + a) + '-' + str(2 * j + b)] not in pathlist:
                                celllist.append(globals()['cell' + str(2 * i + a) + '-' + str(2 * j + b)])
                if len(celllist) == 3:
                    for x in celllist: # One cell in a list of 3 is appended to the path if adjacent
                        if pathlist[0] in x.adjacentlist:
                            pathlist.insert(0, x)
                            celllist.remove(x)
                            break
                        elif pathlist[-1] in x.adjacentlist:
                            pathlist.append(x)
                            celllist.remove(x)
                            break
                cellcyclelist = cycledlist(celllist)
                cellcyclelist.rearrange()
                if len(celllist) == 1: # 1 cell cycles are not unionable
                    notunionlist.append(cellcyclelist)
                elif len(celllist) == 2 and (len(celllist[0].adjacentlist) < 4 and len(celllist[1].adjacentlist) < 4):
                    a = set(celllist[0].adjacentlist).union(celllist[1].adjacentlist).intersection(pathlist)
                    if a == set() or celllist[0].xindex == celllist[1].xindex == list(a)[0].xindex or \
                            celllist[0].yindex == celllist[1].yindex == list(a)[0].yindex:
                        cyclesetlist.append(cellcyclelist)
                    elif len(a) == 1: # Border cycles of 2 with one cell touching the path end are not unionable
                        notunionlist.append(cellcyclelist)
                    else:
                        cyclesetlist.append(cellcyclelist)
                elif len(celllist) == 3: # All lists of 3 are not unionable or difficult to unite
                    notunionlist.append(cellcyclelist)
                elif len(celllist) == 0:
                    pass
                else:
                    cyclesetlist.append(cellcyclelist)
        for x in notunionlist: # Single cells adjacent to the path are appended to it
            if len(x.list) == 1 and pathlist[0] in x.list[0].adjacentlist:
                pathlist.insert(0, x.list[0])
                notunionlist.remove(x)
            elif len(x.list) == 1 and pathlist[-1] in x.list[0].adjacentlist:
                pathlist.append(x.list[0])
                notunionlist.remove(x)
    labyrinthgrid() # Different configurations move the truncated narrow rows and columns until no solitary cells remain
    if len(notunionlist) > 0:
        labyrinthgrid(arange=(0,-2,-1),brange=(0,2))
    if len(notunionlist) > 0:
        labyrinthgrid(arange=(0, 2), brange=(0,-2,-1))
    if len(notunionlist) > 0:
        labyrinthgrid(arange=(0,-2,-1), brange=(0,-2,-1))
    pathcyclelist = cycledlist(pathlist)
    cyclesetlist.append(pathcyclelist)
    def updatecyclesetlist(a, b): # Union the cycles in the grid to create a labyrinth
        nonlocal cyclesetlist
        c = a.union(b)
        if c:
            cyclesetlist.remove(a)
            cyclesetlist.remove(b)
            cyclesetlist.append(c)
    while len(cyclesetlist) > 1:
        a = sample(cyclesetlist,2)
        updatecyclesetlist(a[0], a[1])
    mainlabyrinth=loop(*cyclesetlist[0].list,cycle=True) # Create the labyrinth path by deleting walls
    if pathlist[0] in pathlist[-1].adjacentlist: # If closed loop, break the loop at the start/end point
        buildwallauto(pathlist[0],pathlist[-1])
    if branch != 0: # If branching split path into certain number of segments and unite them randomly
        id = 1
        fullpath = cyclesetlist[0].list[:]
        segmentsize = len(fullpath)//branch
        segmentlist = []
        for i in range(1,branch): # Splitting the labyrinth path
            globals().update({'sublist'+str(id):fullpath[(i-1)*segmentsize:i*segmentsize]})
            buildwallauto(fullpath[i * segmentsize - 1], fullpath[i * segmentsize])
            segment = globals()['sublist'+str(id)]
            segmentset = cellset()
            for x in segment:
                segmentset.items = segmentset.items.union([x])
            segmentlist.append(segmentset)
            id+=1
        globals().update({'sublist' + str(id): fullpath[(branch - 1) * segmentsize:]})
        segment = globals()['sublist' + str(id)]
        segmentset = cellset()
        for x in segment: # Randomly break walls to unite paths
            segmentset.items = segmentset.items.union([x])
        segmentlist.append(segmentset)
        for x in segmentlist:
            x.updateborder()
        mergecellsets(segmentlist)
    entrance.entrance = True
    target.target = True
    createturtle()
    creategoal()

# Create target marker
def creategoal():
    global target
    global goal
    goal = sheet.create_oval(target.xcenter - turtlesize, target.ycenter - turtlesize,
                               target.xcenter + turtlesize, target.ycenter + turtlesize, fill='#ff0000')

# Create player location marker
def createturtle():
    global position
    global turtle
    position = entrance
    turtle = sheet.create_oval(position.xcenter - turtlesize, position.ycenter - turtlesize,
                               position.xcenter + turtlesize, position.ycenter + turtlesize)

# Use arrow keys to move the player location marker
def left(event):
    global position
    global turtle
    if position.xindex!=0:
        if globals()['cell'+str(position.xindex-1)+'-'+str(position.yindex)]in position.connections:
            position = globals()['cell' + str(position.xindex - 1) + '-' + str(position.yindex)]
            sheet.coords(turtle, position.xcenter - turtlesize, position.ycenter - turtlesize,
                     position.xcenter + turtlesize, position.ycenter + turtlesize)
def right(event):
    global position
    global turtle
    if position.xindex!=size[0]-1:
        if globals()['cell' + str(position.xindex + 1) + '-' + str(position.yindex)] in position.connections:
            position = globals()['cell' + str(position.xindex + 1) + '-' + str(position.yindex)]
            sheet.coords(turtle, position.xcenter - turtlesize, position.ycenter - turtlesize,
                         position.xcenter + turtlesize, position.ycenter + turtlesize)
def up(event):
    global position
    global turtle
    if position.yindex!=0:
        if globals()['cell' + str(position.xindex) + '-' + str(position.yindex - 1)] in position.connections:
            position = globals()['cell' + str(position.xindex) + '-' + str(position.yindex-1)]
            sheet.coords(turtle, position.xcenter - turtlesize, position.ycenter - turtlesize,
                         position.xcenter + turtlesize, position.ycenter + turtlesize)
def down(event):
    global position
    global turtle
    if position.yindex!=size[1]-1:
        if globals()['cell' + str(position.xindex) + '-' + str(position.yindex + 1)] in position.connections:
            position = globals()['cell' + str(position.xindex) + '-' + str(position.yindex+1)]
            sheet.coords(turtle, position.xcenter - turtlesize, position.ycenter - turtlesize,
                         position.xcenter + turtlesize, position.ycenter + turtlesize)
# Bind arrow keys
window.bind('<Left>',left)
window.bind('<Right>',right)
window.bind('<Up>',up)
window.bind('<Down>',down)

# Solve maze using Dijkstra's algorithm
def solve(startvertex=None):
    global solution
    global showsolution
    for x in solution: # Delete previous solution
        sheet.delete(x)
    if not solution: # Solve if there is no solution
        showsolution = True
        if startvertex == None:
            start = entrance
        else:
            start = position
        for x in solution:
            sheet.delete(x)
        solution = []
        notpathset = set()
        for i in range(0, size[0]): # Set all tracker values and populate set of unexplored cells
            for j in range(0, size[1]):
                notpathset = notpathset.union([globals()['cell' + str(i) + '-' + str(j)]])
                globals()['cell' + str(i) + '-' + str(j)].pathlist = [globals()['cell' + str(i) + '-' + str(j)]]
                globals()['cell' + str(i) + '-' + str(j)].tracker = size[0] * size[1] + 1
        start.tracker = 0
        pathset = set()
        while target not in pathset: # Dijkstra's algorithm
            currentvertex = min(notpathset, key=lambda x: x.tracker)
            notpathset = notpathset.difference([currentvertex])
            pathset = pathset.union([currentvertex])
            for vertex in currentvertex.connections:
                if vertex in notpathset:
                    if currentvertex.tracker + 1 < vertex.tracker:
                        vertex.tracker = currentvertex.tracker + 1
                        vertex.pathlist = currentvertex.pathlist + vertex.pathlist
        previousvertex = start
        if len(target.pathlist) > 1:
            for vertex in target.pathlist: # Create path lines in red
                stepid = sheet.create_line(previousvertex.xcenter, previousvertex.ycenter,
                                           vertex.xcenter, vertex.ycenter, fill='#ff0000')
                solution.append(stepid)
                previousvertex = vertex
    else: # Otherwise remove solution
        solution = []
        showsolution = False

# Move the target with Ctrl-RightClick
def movetarget(event):
    global target
    global targetdefaultkey
    global solution
    sheet.delete(goal)
    target=incell(event.x, event.y)
    creategoal()
    for x in solution:
        sheet.delete(x)
    solution =[]
    if showsolution == True:
        solve()
    targetdefaultkey = 'cell'+str(target.xindex)+'-'+str(target.yindex)

# Move entrance with Ctr-LeftClick
def moveentrance(event):
    global entrance
    global entrancedefaultkey
    global solution
    sheet.delete(turtle)
    entrance=incell(event.x, event.y)
    createturtle()
    for x in solution:
        sheet.delete(x)
    solution =[]
    if showsolution == True:
        solve()
    entrancedefaultkey = 'cell'+str(entrance.xindex)+'-'+str(entrance.yindex)

# Disable labyrinth checkbox if grid is checked
def grid():
    if gridvar.get() == True:
        gridentry.config(state = NORMAL)
    else:
        gridentry.config(state=DISABLED)
    if labvar.get() == True and gridvar.get() == True:
        labvar.set(False)
        deadendsentry.config(state=DISABLED)

# Disable grid checkbox if labyrinth is checked
def lab():
    if labvar.get() == True:
        deadendsentry.config(state = NORMAL)
    else:
        deadendsentry.config(state=DISABLED)
    if labvar.get() == True and gridvar.get() == True:
        gridvar.set(False)
        gridentry.config(state=DISABLED)

# Generate maze based on selected mode
def generate():
    if gridvar.get() == True:
        subdivide(blocksize=int(gridentry.get()))
    elif labvar.get() == True:
        labyrinth(branch= 10*int(deadendsentry.get()))
    else:
        generatemaze()

# Update default entrance and target to be in opposite corners
def updatedefault():
    global entrancedefaultkey
    global targetdefaultkey
    entrancedefaultkey = 'cell0-0'
    targetdefaultkey = 'cell' + str(size[0] - 1) + '-' + str(size[1] - 1)

# Binding the keys to build and break walls and move the entrance and target
sheet.bind('<Shift-Button-1>', buildwall)
sheet.bind('<Alt-Button-1>', breakwall)
sheet.bind('<Control-Button-1>', moveentrance)
sheet.bind('<Control-Button-3>', movetarget)

# Create all the cells
initialize()

mainloop()