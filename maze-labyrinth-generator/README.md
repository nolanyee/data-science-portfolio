# Maze and Labyrinth Generator
*Skills: Python, Algorithms, Data Structures*

### Overview
This program generates and solves random mazes and labyrinths of variable size. It also allows the user to move a turtle around the maze and has a toggle button to show and hide the solution.

The difference between a maze and a labyrinth is that a labyrinth has only one path and no forks. There are plenty of widely known algorithms for maze generation, but not so much for labyrinth generation. This program uses a unique algorithm for labyrinth generation that involves the use of circular set data structures, which outperforms a depth first search type algorithm. 

The maze generation algorithm uses a disjoint set data structure. 

The program also includes a unique grid type maze, where each grid block is a labyrinth (this algorithm uses depth first search rather than circular lists to generate the mini labyrinths because they are small). Then the grid blocks are treated like disjoint sets and combined to form the overall maze.

The mazes are solved using Dijkstra's algorithm.

### Usage
A screenshot of the user interface is shown below.

<img src="images/MazeFig1.png" width = "800">

The user can specify the width and height of the grid (in terms of the number of cells). The branch parameter determines the maximum number of walls that can be deleted during maze generation. This parameter must be > 2, but does not need to be an integer. The loop parameter creates multiple paths to the target cell.

If Grid is selected, the maze is divided into blocks of specified size, and a labyrinth is generated in each block using
depth first search (keep block size < 7, otherwise the maze generation will be very slow). Then the maze is generated by union of the blocks. 

If labyrinth is selected, an alternative labyrinth generating algorithm is used, based on the union of disjoint cyclical
ordered sets. The dead end parameter controls how likely dead ends will be generated, through subdivision of the
labyrinth path and the performing union on the resulting disjoint paths. 

The user may build or destroy walls in the maze or move the target. Use Alt+Left Click on two cells to destroy the wall between the cells, and Shift+Left Click on two cells to build a wall between the cells. The labyrinth start and end points are set by using Ctrl+Left Click and Ctrl+Right Click. Not all combinations of starting and ending points can yield a labyrinth. In these cases the path will be extended beyond the end or start point. Usually moving either point by 1 space will create a feasible labyrinth.

Depending on the parameters and user actions, there may be multiple solutions to the maze.
The shortest solution path is calculated using Dijkstra's algorithm.

### Maze Generation


### Labyrinth Generation


### Grid Maze Generation

